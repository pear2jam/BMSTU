% Лабораторная работа № 2 «Введение в объектно-ориентированное программирование на языке Scala»
% 30 марта 2024 г.
% Сергей Наумов, ИУ9-62Б

# Цель работы
Целью данной работы является изучение базовых объектно-ориентированных возможностей языка Scala.

# Индивидуальный вариант
Система неравенств вида a1x1 + a2x2 + … + aNxN ≤ b. Конструктор класса должен принимать список коэффициентов ai 
и свободный член b и порождать систему, состоящую из одного неравенства. Операции: «+» — объединение двух систем в одну;
«/» — принимает число i и возвращает систему, полученную из данной системы путём присвоения нулевого значения i-й переменной;
«check» — проверка, удовлетворяет ли список значений переменных системе неравенств.

# Реализация

Код лабораторной работы представляет из себя класс Неравенств \
Одно неравенство хранится как пара из списка коэффициентов и свободного члена
Система неравенств хранится как список неравенств \
Это позволяет легко формировать объединения, применять функции через map\

Класс обладает следущими методами: \
* '+' : ```InequalitySystem -> InequalitySystem```
  Объяединяет две системы неравенств, складывая списки неравенств двух систем \
  Возвращает результирующую систему
* '/' : ```Int -> InequalitySystem``` \
  Зануляет i-ую переменную в системе, удаляя ее из системы \
  Использует метод patch для удаления значения из списка, с помощью map применяем эту функцию к всем неравенствам \
  Возвращает систему с удаленной i-ой переменной
* 'check' : ```List[Double]) -> Boolean``` \
  Подставляет заданную точку и проверяет выполняется ли система неравенств \
  Вычисляет скалярное произведение заданной точки и вектора коэффициентов каждого неравенства
  и сравнивает результат с соответсвутющим свободным членом : если хоть один результат строго больше -
  возвращается false
  Возврашает факт выполнения системы для заданной точки типом Boolean

* Также класс обладает дополнительным конструктором, который принимает одномерный список коэффицентов и
  единственное число - свободный член

  ```scala
  def this(coefficients: List[Double], constants: Double) = {
    this(List(coefficients), List(constants))
  }
  ```
  
  Этот конструктор принимается когда класс используется самим пользователем, чтобы сохранять формат его использования,
  в рамках которого изначально класс представляет одно неравенство



Полный код класса:

```scala
class InequalitySystem(coefficients: List[List[Double]], constants: List[Double]) {

  def this(coefficients: List[Double], constants: Double) = {
    this(List(coefficients), List(constants))
  }
  
  var inequalities: List[(List[Double], Double)] = coefficients.zip(constants)
  
  def +(other: InequalitySystem): InequalitySystem = {
    val combinedInequalities = this.inequalities ++ other.inequalities
    new InequalitySystem(combinedInequalities.map(_._1), combinedInequalities.map(_._2))
  }

  def /(index: Int): InequalitySystem = {
    println(coefficients.toString)
    val newCoefficients = coefficients.map(row => row.patch(index - 1, Nil, 1))
    new InequalitySystem(newCoefficients, constants)
  }

  def check(point: List[Double]): Boolean = {
    inequalities.forall { case (coeffs, constant) =>
      val sum = (coeffs, point).zipped.map(_ * _).sum
      sum <= constant
    }
  }
}
```

# Тестирование

В рамках тестирования проверим работу методов класса

```
var sys = new InequalitySystem(List(1.0, 2.0, -3.0), 6.0) // Задаем первое неравенство
var sys2 = new InequalitySystem(List(4.0, 2.0, -1.0), 2.0) // Задаем второе неравенство
var sys_sum = sys + sys2
println(sys_sum.inequalities.toString()) // Объединение
var sys_mod = sys_sum / 2
println(sys_mod.inequalities.toString) // Удаление переменной
println(sys_mod.check(List(1.0, 2.0)).toString) // Проверка на точке 1
println(sys_mod.check(List(2.0, 5.0)).toString) // Проверка на точке 2
```


```
List((List(1.0, 2.0, -3.0),6.0), (List(4.0, 2.0, -1.0),2.0)) // Неравества объединились
List((List(1.0, -3.0),6.0), (List(4.0, -1.0),2.0)) // Переменная удалилась
true
false
```

# Вывод

В данной лабораторной работе я познакомился с основами объектно-ориентированного программирования на языке Scala.
Моей целью было изучение базовых возможностей объектно-ориентированного подхода и их реализация на примере создания 
класса для работы с системами неравенств.

Что я узнал
Основы объектно-ориентированного программирования: Я изучил основные принципы ООП, такие как инкапсуляция, 
наследование и полиморфизм, и применил их при создании класса для работы с системами неравенств.

Реализация класса в Scala: 
Я написал класс InequalitySystem, который позволяет создавать системы неравенств, 
объединять их, занулять переменные и проверять удовлетворение системы неравенств заданной точкой.

Применение методов работы с коллекциями: 
В процессе работы с классом я использовал методы работы с коллекциями Scala,
такие как zip, map, forall и patch, что позволило мне лаконично реализовать требуемую функциональность.

Тестирование
Я провел тестирование созданного класса, проверив его методы на корректность работы. 
Результаты тестирования показали, что класс работает ожидаемым образом: системы неравенств правильно объединяются,
переменные корректно зануляются, а метод check верно определяет, удовлетворяет ли заданная точка системе неравенств.

Заключение
Лабораторная работа позволила мне погрузиться в мир объектно-ориентированного программирования на языке Scala и 
на практике применить основные принципы ООП. Я узнал, как создавать классы, методы и использовать их для решения 
конкретных задач, что дало мне ценный опыт для дальнейшей работы с этим языком программирования.


